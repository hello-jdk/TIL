### 연산(operate) + 자(-or)

연산자는 피연산자로 연산을 수행을 하면 항상 결과값을 반환한다.

- expression`(식or표현식)`: 연산자와 피연산자를 조합하여 계산하는 것
- evaluation`(평가)`: 메모리or식별자`(identifier)`에 초기화하기위해 결과를 얻는 것
  - 표현식으로 평가를 하여 단발성으로 값을 얻는 경우에도 사용가능

### 부호 연산자 vs 산술 연산자

`-3-5`에서 처음의 `-`는 부호 연산자, 두 번째의 `-`는 뺄셈 연산자이다.
즉, 피연산자는 `-3`,`5` 이며 이항 연산자는 `-`이다.

### 우선 순위에 대해

1. 기본적으로는 산비논대 (산술>비교>논리>대입) 우선순위이다.
   산비논대 안에서도 우선순위가 다르다.

- `x << 2 + 1`

  - 산술 연산자 > 산술 쉬프트 연산자(2^n)
  - `x << 3`

- `data & 0xFF == 0`

  - 비교 연산자 > 논리 비트 연산자
  - `data & (false)`

- `x < -1 || x > 3 && x < 5`
  - 비교 연산자 > 논리 연산자
  - 논리 AND 연산자 > 논리 OR 연산자
    - `(x<-1) || (x>3) && (x<5)`
    - `(x<-1) || ((x>3) && (x<5))`

2. 단이삼 (단항>이항>삼항)

3. 연산자 결합규칙 (진행방향)
   단항(부호연산자,!,~,etc), 대입 연산자 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽

### 산술 변환 (자동 형변환)

1. 큰 자료형으로 타입 일치
2. 모든 연산에서 산술 변환이 일어나는 것은 아니다. (쉬프트, 증감연산자)
3. int형보다 작으면 무조건 int형으로 형변환(byte+short->int)

### prefix 증감연산자 vs postfix 증감연산자

1. 독립적인 하나의 순수 문장(statement)의 경우는 차이가 없음

```
i++;
++i;
```

2. 이외의 경우는 증감->참조및대입, 참조및대입-> 증감

```
System.out.println(i++);
System.out.println(--j);

System.out.println(i);
i++;
--j;
System.out.println(j);

```

### 산술연산자 팁

- `int`형 보다 작은 자료형을 식별자에 저장하고 싶으면 `명시적 형변환`

- 컨벤션: `리터럴`형 연산을 할때는 가독성을 위해 형변환을 명시해주는 것이 좋다.
  (성능적 차이도 없다. 컴파일러에의해 미리 계산되기 때문)

- int형 반올림 구현: `(int)(pi*1000+0.5)/1000` or `Math.round()`

### 비교연산자

- 비교 연산자는 이항 연산자
- 피연산잔의 타입이 서로 다를 경우 `자료형의 범위가 큰` 쪽으로 자동 형변환
- 원시형은 물론 참조형(즉, 모든 자료형)에 사용가능
- 참조형은 메모리 주소를 비교 같은 인스턴스인지 비교
- 원시형과 참조형은 서로 비교 불가

- double default인 이유

```
10 == 10.0f // true
'A' > 'B'   // false

//float와 double 부동소수점 오차
0.1 == 0.1f // false

float f = 0.1f  // 0.1000000149011612
double d = 0.1; // 0.1000000000000001
즉, 같지않다.
```

### 단축평가 or 효율적연산 (short circuit evaluation)

- js 동일 왼쪽 우선
- 컨벤션: `!('a' <= ch && ch <= 'z')`

### 논리 비트연산자

- 2의보수: ~10 -> -11

### 산술 쉬프트연산자

- `*`, `/` 보다 빠르다
- 컨벤션: 실행속도 요구되어지는 곳만 사용

### 삼항 조건연산자

```
result = x>y ? x:y;

if(x>y)
    result = x;
else
    reulst = y;
```

### 대입 연산자 op=

`x = y = 3`

오른쪽에서 왼쪽 (rvalue -> lvalue)

1. 3 -> y
2. (y=3) -> x
