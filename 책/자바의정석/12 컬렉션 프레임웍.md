# 컬렉션 프레임웍

데이터 군을 저장하는 클래스들을 표준화한 설계
JDK1.2

## 인터페이스

Collection: List와 Set의 상위 인터페이스

List: 순서가 있는 데이터의 집합, 데이터의 중복 허용
`ArrayList` `LinkedList` `Stack` `Vector`

Set: 순서가 없는 데이터의 집합, 데이터의 중복 불허
`HashSet` `TreeSet`

Map: key와 value의 쌍으로 이루어진 집합, 순서가 없고, 키는 중복 불허, 값은 중복 허용
`HashMap` `TreeMap` `Hashtable` `Properties`

모든 컬렉션 프레임웍은 이 셋 중의 하나를 구현하고 있다.
예외 `Vector` `Stack` `Hashtable` `Properties`

### Collection 인터페이스

```
Collection ㅡ List
           ㄴ Set
```

### List 인터페이스

```
List ㅡ Vector      ㅡ stack
     ㄴ ArrayList
     ㄴ LinkedList
```

### Set 인터페이스

```
Set ㅡ HashSet
    ㄴ SortedSet    ㅡ TreeSet
```

### Map 인터페이스

```
Map ㅡ Hashtable
    ㄴ HashMap      ㅡ LinkedHashMap
    ㄴ SortedMap    ㅡ TreeMap
```

Collection 타입으로 반환 가능

- Map.Entry 인터페이스

Map인터페이스의 내부 인터페이스
{Key:Value}의 객체의 Entry에 관한 정의를 담당

### 정리

```
Collection  ㅡ List        ㅡ Vector       ㅡ stack
                           ㄴ ArrayList
                           ㄴ LinkedList
            ㄴ Set         ㅡ HashSet
                           ㄴ SortedSet    ㅡ TreeSet

               Map         ㅡ Hashtable
                           ㄴ HashMap      ㅡ LinkedHashMap
                           ㄴ SortedMap    ㅡ TreeMap
```

## ArrayList vs LinkedList

- ArrayList

`Vector` 클래스 개선

장점: 읽기 빠름, 순차적인 로직에는 빠름
단점: 중간 값에 대한 추가,수정 느림, capacity가 정해져있음

- LinkedList

장점: 중간 값에 대한 추가,수정이 빠르다. capacity가 따로없어 메모리 효율
단점: 값이 많아질 수록 접근성이 떨어짐

## Queue의 구현체들

- deQueue(Double-Ended Queue)

<img width="100%" src="https://user-images.githubusercontent.com/57665888/198827305-02bae49b-8af8-4ec3-9a13-4d4bc09dc767.png">

`Deque` 클래스를 사용하면 양쪽에서 삽입,제거가 가능하다.

- PriorityQueue

우선순위 큐

## 이터레이터

컬렉션에 저장된 요소를 접근하는데 사용하는 인터페이스

- 버전별 순서

Enumberation: `Iterator`의 구버전 (predecated)
Iterator: (단방향)
ListIterator: `Iterator`의 기능을 향상 시킨 것 (양방향)

- 기본메서드

`Collection` 인터페이스에 정의된 메서드이므로 `List`와 `Set` 사용가능
허나, Set의 이터레이터 순서는 보장되지 않는다.

```
boolean hasNext(): 다음 요소 존재유무
Object next(): 다음 요소 읽어오기
void remove(): 다음 요소 삭제
```

- Iterator 메서드의 반환값

<img width="100%" alt="1" src="https://user-images.githubusercontent.com/57665888/198828262-2412fa74-40f4-4dce-98d6-9bb0a63b9fb0.png">

반환값으로 변환된 객체를 리턴하면 함수형 프로그래밍이 가능하다.

```
StringBuffer sb = new StringBuffer();
sb.append("A");
sb.append("B");

// 똑같음
sb.append("A").append("B");
```

### ListIterator

- 기본메서드

```
void        add(Obejct o)
boolean     hasNext()
boolean     hasPrevious()
Object      next()
Object      previous()

int         nextIndex()
int         previousIndex()

// optional
void        remove()            // 반드시 next()나 previous()를 호출한 다음에 호출해야한다.
void        set(Object o)       // 반드시 next()나 previous()를 호출한 다음에 호출해야한다.
```

remove()는 다음것을 삭제하는것이 아닌 읽어온 값을 삭제한다.
set() 또한 마찬가지

## Arrays

- copyOf

```
public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    @SuppressWarnings("unchecked")
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                        Math.min(original.length, newLength));
    return copy;
}
```

해당 배열의 새로운 인스턴스를 복사해서 반환한다.
`copyOfRange()` 또한 마찬가지

- fill(), setAll()

```
int[] arr = new int[5];
Arrays.fill(arr, 9);
for (int v : arr) {
    System.out.print(" " + v);
}

// 9 9 9 9 9

Arrays.setAll(arr, (v) -> (int) (Math.random() * 4) + 1);
for (int v : arr) {
    System.out.print(" " + v);
}

// 1 ~ 4까지의 랜덤값 5개

```

- sort()

sort(): 배열 정렬

- binarySearch()

이진 검색
배열에 저장된 요소 검색
배열이 정렬되어있어야 올바른 결과값

- equals(), deepEquals()

다차원 배열은 `deepEquals()` 사용

- asList(Object.. a)

배열을 `List` 로 변환

- parallelXXX()

멀티 쓰레드로 작업, 빠름

- spliterator()

멀티 쓰레드로 작업, `Spiliterator` 반환

- stream()

컬렉션을 스트림으로 변환

## Comparator, Comparable

Comparable: 기본 정렬 기준
Comparator: 기본 정렬 기준 외 정렬 기준 재정의 하고싶을때

```
class Descending implements Comparator {
	@Override
	public int compare(Object o1, Object o2) {
		if(o1 instanceof Comparable && o2 instanceof Comparable){
			Comparable v1 = (Comparable) o1;
			Comparable v2 = (Comparable) o2;
			return v1.compareTo(v2) * -1;
		}
		return -1;
	}
}
```

- String의 기본정렬

사전순
공백-> 숫자-> 대문자-> 소문자

`Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);`
대소문자 구분없이 정렬

## HashSet

중복을 피하고 순서를 유지하고싶으면 `LinkedHashSet` 사용
