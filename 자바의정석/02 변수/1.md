### 변수란

- 단 하나의 값을 저장할 수 있는 메모리 공간

단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.

### 변수를 선언, 초기화한다

1. `변수타입`에 알맞는 크기의 메모리 저장공간이 확보
2. 이 저장공간을 `변수이름`을 통해 사용한다.

### 변수이름 == 식별자`(identifier)`

1. 대소문자 구분, 길이에 제한없음
2. 예약어
3. 숫자로 시작불가
4. 특수문자는 `_` 와 `$`만 호용

### 기본형과 참조형 타입

기본형(원시형) 변수: 실제 값을 identifier에 저장
참조형 변수: 값이 저장되어 있는 메모리 주소를 identifier에 저장

- 메모리주소: 메모리에는 1 byte단위로 일련번호가 붙는다.

### 참조형 변수

- 자바에서는 참조형은 객체(클래스)
- JVM의 비트에 따라 참조형 변수의 크기가 달라진다.

### 원시형

- `char`: 유니코드
- `boolean`을 제외한 7개의 기본형은 서로 연산과 변환이 가능
- `int`은 CPU가 가장 효율적으로 처리할 수 있는 타입
- 메모리 절약 : `byte` or `short`

1 byte = boolean, byte
2 byte = char, short
4 byte = int, float
8 byte = long, double

- float의 어원은 부동소수점 방식
- short < int < long : 쇼트와 롱의 어원은 인트 기준
- double의 어원은 float의 저장공간 두배 (정밀도만 높고, 수의 최대값은 더 작다.)

### 상수 constant

값을 한 번 저장하면 변경할 수 없는 `저장공간`

- 상수는 선언과 동시에 초기화 시켜야한다.
- 모두 대문자로 (암묵적 관례, `_`이용)

### 리터럴

- 문자 그대로
- `저장공간`은 아니기 때문에 구분을 위해 만든 용어
- 진수

```
    int 8진수   = 0o10; // == 8
    int 16진수  = 0x10; // == 16
    int 2진수   = 0b10; // == 2
```

- 접미사

```
    long big = 100_000_000_000L;        // 10^12
    long hex = OxFFFF_FFFF_FFFF_FFFFL   // 16^15 + 16^14 + ... + 16^0
```

정수형(Long타입): L `(default int형)`
실수형: f(float), d(double) `(default double형)`

> 상수와 리터럴은 의미가 있어야 한다.

### String의 덧셈 연산자

```
    7   + " "   -> "7" + " "    -> "7 "
    " " + 7     -> " " + "7"    -> " 7"

    7 + "7"     -> "7" + "7"    -> "77"
    7 + 7 + ""  -> 14 + ""      -> "14" + ""    -> "14"
    "" + 7 + 7  -> "7" + 7      -> "7" + "7"    -> "77"

    true + ""   -> "true" + ""  -> "true"
    null + ""   -> "null" + ""  -> "null"
```

순서 주의

### console.log()

JDK1.6의 Console 클래스 = Scanner

### bit byte word

word = CPU가 한번에 처리할 수 있는 데이터의 크기 (32,64 bit)

### 2 8 16 진수

8진수 : 2진수 `3자리 222`
16진수 : 2진수 `4자리 2222`

### 실수 진법변환

```
    0.625 _(10)

    // 1. 소수 부분만 빼서 * 2
    0.625 * 2 = 1.25 // 1
    0.250 * 2 = 0.50 // 0
    0.500 * 2 = 1.00 // 1

    // 2. 결과값 정수 부분 위에서부터 나열
    0.101_(2)
```

- 다른 진법으로 변환팁
  `10진 소수 -> 10진 소수: 곱하기 2를 10으로만 바꿧을 뿐`
  (2 -> 8,16)

```
    // 1. 소수 부분만 빼서 * 10
    0.625 * 10 = 6.25 // 6
    0.250 * 10 = 2.50 // 2
    0.500 * 10 = 5.00 // 5

    // 2. 결과값 정수 부분 위에서부터 나열
    0.625_(10)
```

### 음수의 진수표현 (보수법)

1. MSB(Most Significant Bit)으로 구분하자
   0: 양수
   1: 음수

```
    0000 // 0
    0001 // 1
    ...
    0111 // 7
    1000 // -0
    ...
    1111 // -7
```

- (+5) + (-5) = 0
  +0101
  +1101
  =0010
  > 단점 : (0이 되지않음) && (0,-0 두가지 0이 존재)

2. 0으로 만들기 위한 보수 표현이용

```
    0000 // 0
    0001 // 1
    ...
    0111 // 7
    1000 // -8
    ...
    1111 // -1
```

- (+5) + (-5) = 0
  +0101
  +1011
  =0000

### 보수 구하기

1. 더하면 0이 되는 값을 찾기

```
5 =>

0101 + ???? = 0000
???? = 1011
```

2. 2의 보수 = 1의 보수 + 1

```
0101 -> 1010 + 1 = 1011
```

- 2진수의 1수의 보수를 더하면 모든 자리수가 1이 됨

```
0101 + 1010         = 1111
0101 + (1010 + 1)   = 1111 + 1
0101 + (1의보수 + 1) = 0000
```

### 오버 플로우와 언더 플로우

정수형의 오버 플로우 발생시 : 최솟값
실수형의 오버 플로우 발생시 : 무한대
실수형의 언더 플로우 발생시 : 0

- 실수형의 자료크기: 클수록 얼마나 0에 가까울수 있는가

### 표현 방식

1. 정수형

- S: 부호비트
- n: 타입의 크기

2. 실수형

- S: 부호비트
- E: 지수
- M: 가수
- 즉, (S:+-)M\*(2^E)

부동소수점 표현방법에대해 더 궁금하다면 `IEEE754`

### 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.

- 크기가 큰 자료형에서 크기가 작은 자료형으로는 자동 형변환이 안됨을 의미
