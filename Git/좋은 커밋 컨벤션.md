# 커밋 컨벤션

지금까지 커밋 컨벤션을 좋아 보이는 것을 따라 했었는데, 그러다 보니 내가 작업한 코드 내용을 어떠한 커밋 메시지로 담아야 할지 헷갈릴 때가 많았다. 슬슬 정리할 때가 됐다.다벤션의 경우 어느 집단에 가느냐에 따라지므로 이해만을 목적으로 [Udacity](https://udacity.github.io/git-styleguide/) Git 컨벤션과 개인의 경험을 첨가하여 작성한다.

<b>컨벤션인만큼 가변성을 가지고 있다</b>
하지만 [목표](https://djkeh.github.io/articles/How-to-write-a-git-commit-message-kor/)는 변하지 않는다.

1. 더 좋은 커밋 로그 가독성
2. 더 나은 협업과 리뷰 프로세스
3. 더 쉬운 코드 유지보수

## 요약

<b>사용할 한 줄짜리 커밋 메시지</b><br>
태그(옵션): 한 줄 커밋

<b>프로덕션에 영향이 없는 코드</b>

```
Init: 프로젝트 환경 설정
Docs: 문서
Rename: 파일 및 폴더 이름 변경
Remove: 파일 및 폴더 삭제
Chore: 빌드 변경
```

<b>프로덕션 코드 개선</b>

```
Refactor: 기능 고도화
Style: 코드 컨벤션
Comment: 주석
```

<b>프도덕션 코드 핵심</b>

```
Feat: 새로운 기능
Fix: 의도치 않는 코드 변경
```

<b>약속</b>

1. 이모지, 특수기호, 마침표, 쉼표 X
2. how vs `what why` : 무엇을 왜 변경하였는가
3. `구문` vs 문장 : 마침표를 안찍는 이유
4. 영어 vs `한글` : 같이 일하는 사람이 누구인가
5. `명령` vs 설명 : 이 커밋에 있는 코드는 XXX 했다. 직관적 느낌

## 프로덕션에 영향이 없는 코드

1. Init

<b>전체 코드에 대한 개요를 설명할 수 있다.</b><br>
이 프로젝트는 어떤 환경에서 어떤 프로젝트를 향해 갈 것인가를 적을 수 있다.

<b>애플리케이션이 시작되기 이전의 환경을 만들때 사용한다.</b><br>
첫 커밋으로 최대한 적게(1번) 만드는 것을 목표로 하며
IDE나 엔진(Gradle,node.js) 혹은 프레임워크(Spring,Spring boot,Express)에 의해 생성되는 파일과 디렉터리에 대한 정보만 가지고 있다.

<b>라이브러리</b><br>
라이브러리를 이용해 프로덕션 코드(비즈니스 로직)에 영향이 가기 전까지만 만들어서 커밋을 한다. 예를 들어 npm에서 익스프레스나 DB에 대한 클라이언트 라이브러리를 추가하는 것까지만 만들고 DB에 대한 정보 설정은 하지 않아야 한다.

<b>init 이 후 빌드에 관련된 코드변경시</b><br>
init 이후에 진행하면서 빌드나 패키지 매니저, 의존관계를 변경할 때는 chore를 사용한다.

2. Docs

말 그대로 Readme.md나 apiDocs등 기타 문서에 대한 생성, 변경에 대한 커밋 메시지

<b>Docs(옵션)</b><br>
문서가 많아진다면 태그(옵션)에 따라 커밋 메시지를 변경한다.

```

`Docs : Readme 유저 API 설명 추가 및 수정`
`Docs(Readme): 유저 API Docs 링크 및 배포 링크 추가`

```

3. Rename

<b>파일 및 디렉터리 이름 변경</b><br>
파일과 디렉터리의 이름이 변경이 필요한 경우 사용한다.
파일생성이 필요하거나 디렉터리 생성의 경우 Feat에 해당 기능과 함께 커밋한다.

4. Remove

<b>파일 디렉터리 삭제</b><br>
해당 기능이 필요 없거나 다른 기능에 의해 합쳐져 중복에 의해 삭제해야 할 때만 명시해 준다.

5. Chore

<b>프로젝트 진행 중 빌드환경이 변할때</b><br>
어떠한 기능을 구현해야 할 때 필요한 라이브러리, 서드파티를 추가해야 할 때 사용한다. Init과 마찬가지로 정보설정은 Feat에 의해 해준다.
(커밋이 너무 많다면 합칠 필요도 있어 보인다.)

```

Chore(Redis): 캐시 DB 추가
Feat(Redis): 클라우드 설정 정보

```

6. Test

<b>테스트와 관련된 모든 코드</b><br>
테스트 코드는 프로덕션 코드에 영향을 끼치지 않으므로 완전히 분리된 코드가 커밋되어야한다. 생성, 변경, 삭제, 등등 테스트 코드와 관련된 모든 내용을 담을 수 있다..

## 프로덕션 코드 개선

1. Refactor

기존의 코드가 있어야 하며, 프로덕션 코드에 영향을 끼쳐야 한다.
바뀐 코드는 기존의 코드와 기능이 달라져야 한다.

<b>기능의 의미</b><br>
확장도 기능추가의 의미와 같은데
예를 들어 게시글 조회 기능을 유저 등급에 의해 다르게 사용할 수 있게 하는 것은 기능이 달라진 것이다.
게시글을 조회한다는 큰 의도를 유지한 체 구체화, 확장성, 성능 등이 변할 때 사용

<b>의도대로 작동하지 않은 것을 발견했다면</b><br>
기존의 코드가 나의 의도대로 작동하지 않았다는 것을 확인하고 고친다면 Fix를 사용한다.

2. Style

<b>코드 컨벤션</b><br>
코드의 컨벤션을 변경하거나 혹은 까먹고 자동 줄 맞춤하지 않았을 경우 사용한다.
기타 세미 콜론 누락이나 줄 간격을 바꿀 때도 사용한다.
코드에 전혀 영향이 없이 코드를 이쁘게 만들고 싶을 때 사용한다고 보면 된다.

3. Comment

본인의 경우는 API 안에서 개발자의 의도대로 로직을 만들기 위해 세부적으로 기능의 순서를 주석으로 작성하는 편인데 이렇게 코드 이전에 작성하는 것도 포함한다.

<b>모든 코멘트</b><br>
이후 해당 메서드에 대한 설명, 구현이 필요한 로직, TODO와 관련된 주석도 세부적으로 나눠서 커밋한다. 주석에 대한 이야기는 길어질 것 같아 링크를 하나 남기고 주석에 대한 모든 것들을 해당 커밋에 넣어야 한다는 것만 알아두자

[좋은 주석이란?](https://kukuta.tistory.com/388)

## 프로덕션 코드 핵심

1. Feat

<b>큰 기능과 작은 기능</b><br>
프로젝트를 하다보면 하나의 API를 하나의 Feat 커밋으로 담아서 올린 경우가 많았다.
하지만 이것은 지양돼야 한다.
API 하나를 로직 흐름 또는 하나의 요구사항이라고 간주하고 요구사항을 만족하기 위한 여러 기능으로 나눠서 작성해야 한다.

<b>특정 케이스와 특정 클라이언트에게</b><br>
말 그대로 로직을 작성했지만, 특정 사례 또는 특정 클라이언트에게는 제대로 작동하지 않는 일이 발생한다면 Feat 또는 Fix를 사용한다. 특정 클라이언트에게 작동하게 하는 확장의 의미에서는 Feat을 사용해도 되지만 치명적이라 빠른 approve가 필요하다면! HotFix를 사용했던 것 같다.

2. Fix

<b>나의 의도대로 작동하지가 않는다</b><br>
말 그대로 로직을 작성했지만, 처음의 요구사항을 만족하지 않았을 때 작성한다.
대부분 기한을 넘기기 전에는 Feat 또는 Refactor 기한을 넘기고 나서는 Fix로 작성한다.

<b>내가 실수한 부분을 굳이 문서로 남길 필요가 있을까?</b><br>
라는 생각으로 Fix는 잘 쓰지 않는 경향이 있는 것 같다.
TDD를 써서 확인 후에도 문제를 발견이 됐다면 과감히 사용한다.
